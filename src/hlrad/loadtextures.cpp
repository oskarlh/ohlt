#include "color.h"
#include "hlrad.h"
#include "log.h"
#include "util.h"
#include "wad_structs.h"
#include "worldspawn_wad_value_parser.h"

#include <cstring>

int g_numtextures;
std::unique_ptr<radtexture_t[]> g_textures;

std::vector<std::filesystem::path> g_wadDirs;

void AddWadFolder(std::filesystem::path path) {
	g_wadDirs.emplace_back(std::move(path));
}

struct wadfile_t final {
	wad_lumpinfo* lumpinfos;
	FILE* file;
	std::filesystem::path path;
	int filesize;
	int numlumps;
};

std::vector<wadfile_t> g_wadFiles;

bool g_wadfiles_opened;

static int lump_sorter_by_name(void const * lump1, void const * lump2) {
	wad_lumpinfo* plump1 = (wad_lumpinfo*) lump1;
	wad_lumpinfo* plump2 = (wad_lumpinfo*) lump2;
	return ordering_as_int(plump1->name <=> plump2->name);
}

void OpenWadFile(std::filesystem::path name, bool fullpath = false) {
	wadfile_t wad{};
	if (fullpath) {
		wad.path = std::move(name);
		wad.file = fopen(wad.path.c_str(), "rb");
		if (!wad.file) {
			Error("Couldn't open %s", wad.path.c_str());
		}
	} else {
		for (std::filesystem::path const & dirPath : g_wadDirs) {
			wad.path = dirPath / name;
			wad.file = fopen(wad.path.c_str(), "rb");
			if (wad.file) {
				break;
			}
		}
		if (!wad.file) {
			Fatal(
				assume_msg::COULD_NOT_LOCATE_WAD,
				"Could not locate wad file %s",
				name.c_str()
			);
			return;
		}
	}
	Log("Using Wadfile: %s\n", wad.path.c_str());
	wad.filesize = q_filelength(wad.file);
	wadinfo_t wadinfo;
	if (wad.filesize < (int) sizeof(wadinfo)) {
		Error("Invalid wad file '%s'.", wad.path.c_str());
	}
	SafeRead(wad.file, &wadinfo, sizeof(wadinfo));
	wadinfo.numlumps = (wadinfo.numlumps);
	wadinfo.infotableofs = (wadinfo.infotableofs);
	if (!has_wad_identification(wadinfo)) {
		Error("%s isn't a Wadfile!", wad.path.c_str());
	}
	wad.numlumps = wadinfo.numlumps;
	if (wad.numlumps < 0 || wadinfo.infotableofs < 0
	    || wadinfo.infotableofs + wad.numlumps * (int) sizeof(wad_lumpinfo)
	        > wad.filesize) {
		Error("Invalid wad file '%s'.", wad.path.c_str());
	}
	wad.lumpinfos = (wad_lumpinfo*) malloc(
		wad.numlumps * sizeof(wad_lumpinfo)
	);
	hlassume(wad.lumpinfos != nullptr, assume_msg::NoMemory);
	if (fseek(wad.file, wadinfo.infotableofs, SEEK_SET)) {
		Error("File read failure: %s", wad.path.c_str());
	}
	for (std::size_t i = 0; i < wad.numlumps; ++i) {
		SafeRead(wad.file, &wad.lumpinfos[i], sizeof(wad_lumpinfo));
		if (!wad.lumpinfos[i].name.validate_and_normalize()) {
			Error(
				"Texture number %zu has a bad name. The WAD file %s has been corrupted or it was generated by a program that either incorrectly tries to write texture names longer than 15 code units or writes non-UTF-8 names.",
				i,
				wad.path.c_str()
			);
		}
		wad.lumpinfos[i].filepos = (wad.lumpinfos[i].filepos);
		wad.lumpinfos[i].disksize = (wad.lumpinfos[i].disksize);
		wad.lumpinfos[i].size = (wad.lumpinfos[i].size);
	}
	qsort(
		wad.lumpinfos,
		wad.numlumps,
		sizeof(wad_lumpinfo),
		lump_sorter_by_name
	);

	g_wadFiles.push_back(std::move(wad));
}

void TryOpenWadFiles() {
	if (g_wadfiles_opened) {
		return;
	}
	g_wadfiles_opened = true;

	std::filesystem::path const filePath{
		path_to_temp_file_with_extension(g_Mapname, u8".wa_").c_str()
	};
	if (std::filesystem::exists(filePath)) {
		OpenWadFile(filePath.c_str(), true);
	} else {
		Warning("Couldn't open %s", filePath.c_str());
		Log("Opening wad files from directories:\n");
		if (g_wadDirs.empty()) {
			Warning("No wad directories have been set.");
		} else {
			for (std::filesystem::path const & dirPath : g_wadDirs) {
				Log("  %s\n", dirPath.c_str());
			}
		}
		std::u8string_view wadValue = value_for_key(
			&g_entities[0], u8"wad"
		);
		for (std::u8string_view wadFilename :
		     worldspawn_wad_value_parser(wadValue)) {
			OpenWadFile((char const *) std::u8string(wadFilename).c_str());
		}
		while (!wadValue.empty()) {
			char8_t const * nextSeparator = std::ranges::find(
				wadValue, u8';'
			);
			std::u8string_view pathString{ wadValue.data(), nextSeparator };

			if (!pathString.empty()) {
				OpenWadFile(
					filename_in_file_path_string_as_path(pathString).c_str()
				);
			}

			if (pathString.length() == wadValue.length()) {
				wadValue = {};
			} else {
				wadValue = wadValue.substr(pathString.length() + 1);
			}
		}
	}
	CheckFatal();
}

void TryCloseWadFiles() {
	if (!g_wadfiles_opened) {
		return;
	}
	g_wadfiles_opened = false;
	for (wadfile_t& wadfile : g_wadFiles) {
		free(wadfile.lumpinfos);
		fclose(wadfile.file);
	}
	g_wadFiles.clear();
}

static void DefaultTexture(radtexture_t* tex, wad_texture_name name) {
	int i;
	tex->width = 16;
	tex->height = 16;
	tex->name = name;
	tex->canvas = std::make_unique<std::uint8_t[]>(
		tex->width * tex->height
	);
	for (i = 0; i < 256; i++) {
		tex->palette[i].fill(0x80);
	}
}

void LoadTexture(radtexture_t* tex, miptex_t const * mt, int size) {
	miptex_t const * header = mt;
	std::uint8_t const * data = (std::uint8_t const *) mt;
	tex->width = header->width;
	tex->height = header->height;
	tex->name = header->name;
	if (tex->width <= 0 || tex->height <= 0
	    || tex->width % (2 * 1 << (MIPLEVELS - 1)) != 0
	    || tex->height % (2 * (1 << (MIPLEVELS - 1))) != 0) {
		Error(
			"Texture '%s': dimension (%dx%d) is not multiple of %d.",
			tex->name.c_str(),
			tex->width,
			tex->height,
			2 * (1 << (MIPLEVELS - 1))
		);
	}
	int mipsize, i;
	for (mipsize = 0, i = 0; i < MIPLEVELS; i++) {
		if ((int) mt->offsets[i] != (int) sizeof(miptex_t) + mipsize) {
			Error(
				"Texture '%s': unexpected miptex offset.", tex->name.c_str()
			);
		}
		mipsize += (tex->width >> i) * (tex->height >> i);
	}
	if (size < (int) sizeof(miptex_t) + mipsize + 2 + 256 * 3) {
		Error("Texture '%s': no enough data.", tex->name.c_str());
	}
	if (*(unsigned short*) &data[sizeof(miptex_t) + mipsize] != 256) {
		Error("Texture '%s': palette size is not 256.", tex->name.c_str());
	}
	tex->canvas = std::make_unique_for_overwrite<std::uint8_t[]>(
		tex->width * tex->height
	);
	for (int i = 0; i < tex->height; i++) {
		for (int j = 0; j < tex->width; j++) {
			tex->canvas[i * tex->width + j]
				= data[sizeof(miptex_t) + i * tex->width + j];
		}
	}
	for (int i = 0; i < 256; i++) {
		for (int j = 0; j < 3; j++) {
			tex->palette[i][j]
				= data[sizeof(miptex_t) + mipsize + 2 + i * 3 + j];
		}
	}
}

void LoadTextureFromWad(radtexture_t* tex, miptex_t const * header) {
	bool loadedTexture = false;
	tex->width = header->width;
	tex->height = header->height;
	tex->name = header->name;
	for (wadfile_t& wad : g_wadFiles) {
		wad_lumpinfo temp;
		temp.name = tex->name;
		wad_lumpinfo* found = (wad_lumpinfo*) bsearch(
			&temp,
			wad.lumpinfos,
			wad.numlumps,
			sizeof(wad_lumpinfo),
			lump_sorter_by_name
		);
		if (found) {
			Developer(
				developer_level::message,
				"Texture '%s': found in '%s'.\n",
				tex->name.c_str(),
				wad.path.c_str()
			);
			if (found->type != 67 || found->compression != 0) {
				continue;
			}
			if (found->disksize < (int) sizeof(miptex_t)
			    || found->filepos < 0
			    || found->filepos + found->disksize > wad.filesize) {
				Warning(
					"Texture '%s': invalid texture data in '%s'.",
					tex->name.c_str(),
					wad.path.c_str()
				);
				continue;
			}
			miptex_t* mt = (miptex_t*) malloc(found->disksize);
			hlassume(mt != nullptr, assume_msg::NoMemory);
			if (fseek(wad.file, found->filepos, SEEK_SET)) {
				Error("File read failure");
			}
			SafeRead(wad.file, mt, found->disksize);
			if (!mt->name.validate_and_normalize()) {
				Warning(
					"Texture '%s': invalid texture data in '%s'.",
					tex->name.c_str(),
					wad.path.c_str()
				);
				free(mt);
				continue;
			}
			Developer(
				developer_level::message,
				"Texture '%s': name '%s', width %d, height %d.\n",
				tex->name.c_str(),
				mt->name.c_str(),
				mt->width,
				mt->height
			);
			if (!strings_equal_with_ascii_case_insensitivity(
					mt->name, tex->name
				)) {
				Warning(
					"Texture '%s': texture name '%s' differs from its reference name '%s' in '%s'.",
					tex->name.c_str(),
					mt->name.c_str(),
					tex->name.c_str(),
					wad.path.c_str()
				);
			}
			LoadTexture(tex, mt, found->disksize);
			free(mt);
			loadedTexture = true;
			break;
		}
	}
	if (!loadedTexture) {
		Warning(
			"Texture '%s': texture is not found in wad files.",
			tex->name.c_str()
		);
		DefaultTexture(tex, tex->name);
		return;
	}
}

void LoadTextures() {
	if (!g_notextures) {
		Log("Load Textures:\n");
	}
	g_numtextures = g_texdatasize
		? ((dmiptexlump_t*) g_dtexdata.data())->nummiptex
		: 0;
	g_textures = std::make_unique<radtexture_t[]>(g_numtextures);
	hlassume(g_textures != nullptr, assume_msg::NoMemory);
	int i;
	for (i = 0; i < g_numtextures; i++) {
		int offset = ((dmiptexlump_t*) g_dtexdata.data())->dataofs[i];
		int size = g_texdatasize - offset;
		radtexture_t* tex = &g_textures[i];
		if (g_notextures) {
			DefaultTexture(tex, wad_texture_name{ u8"default" });
		} else if (offset < 0 || size < (int) sizeof(miptex_t)) {
			Warning(
				"Invalid texture data in '%s'.",
				path_to_temp_file_with_extension(g_Mapname, u8".bsp")
					.c_str()
			);
			DefaultTexture(tex, wad_texture_name{ u8"" });
		} else {
			miptex_t* mt = (miptex_t*) &g_dtexdata[offset];
			if (mt->offsets[0]) {
				Developer(
					developer_level::message,
					"Texture '%s': found in '%s'.\n",
					mt->name.c_str(),
					path_to_temp_file_with_extension(g_Mapname, u8".bsp")
						.c_str()
				);
				Developer(
					developer_level::message,
					"Texture '%s': width %d, height %d.\n",
					mt->name.c_str(),
					mt->width,
					mt->height
				);
				LoadTexture(tex, mt, size);
			} else {
				TryOpenWadFiles();
				LoadTextureFromWad(tex, mt);
			}
		}
		{
			float3_array total{};
			for (int j = 0; j < tex->width * tex->height; j++) {
				float3_array reflectivity;
				if (tex->name.is_transparent_or_decal()
				    && tex->canvas[j] == 0xFF) {
					reflectivity.fill(0.0);
				} else {
					auto const & rgb
						= tex->palette[(std::size_t) tex->canvas[j]];
					reflectivity = { rgb[0] * float(1.0 / 255.0),
						             rgb[1] * float(1.0 / 255.0),
						             rgb[2] * float(1.0 / 255.0) };
					for (float& r : reflectivity) {
						r = std::pow(r, g_texreflectgamma);
					}
					reflectivity = vector_scale(
						reflectivity, g_texreflectscale
					);
				}
				total = vector_add(total, reflectivity);
			}
			total = vector_scale(
				total, 1.0f / (float) (tex->width * tex->height)
			);
			tex->reflectivity = total;
			Developer(
				developer_level::message,
				"Texture '%s': reflectivity is (%f,%f,%f).\n",
				tex->name.c_str(),
				tex->reflectivity[0],
				tex->reflectivity[1],
				tex->reflectivity[2]
			);
			if (vector_max_element(tex->reflectivity)
			    > 1.0 + NORMAL_EPSILON) {
				Warning(
					"Texture '%s': reflectivity (%f,%f,%f) greater than 1.0.",
					tex->name.c_str(),
					tex->reflectivity[0],
					tex->reflectivity[1],
					tex->reflectivity[2]
				);
			}
		}
	}
	if (!g_notextures) {
		Log("%i textures referenced\n", g_numtextures);
		TryCloseWadFiles();
	}
}

// color quantization algorithm

constexpr std::size_t CQ_DIMENSIONS = 3;

template <class T, class T2, class T3>
inline void CQ_VectorSubtract(
	T const a[CQ_DIMENSIONS], const T2 b[CQ_DIMENSIONS], T3 c[CQ_DIMENSIONS]
) {
	for (int x = 0; x < CQ_DIMENSIONS; x++) {
		c[x] = a[x] - b[x];
	}
}

template <class T, class T2, class T3>
inline void CQ_VectorAdd(
	T const a[CQ_DIMENSIONS], const T2 b[CQ_DIMENSIONS], T3 c[CQ_DIMENSIONS]
) {
	for (int x = 0; x < CQ_DIMENSIONS; x++) {
		c[x] = a[x] + b[x];
	}
}

template <class T, class T2>
inline void
CQ_VectorScale(T const a[CQ_DIMENSIONS], const T2 b, T c[CQ_DIMENSIONS]) {
	for (int x = 0; x < CQ_DIMENSIONS; x++) {
		c[x] = a[x] * b;
	}
}

template <class T, class T2>
inline void CQ_VectorCopy(T const a[CQ_DIMENSIONS], T2 b[CQ_DIMENSIONS]) {
	for (int x = 0; x < CQ_DIMENSIONS; x++) {
		b[x] = a[x];
	}
}

template <class T>
inline void CQ_VectorClear(T a[CQ_DIMENSIONS]) {
	for (std::size_t x = 0; x < CQ_DIMENSIONS; ++x) {
		a[x] = (T) 0;
	}
}

template <class T>
inline T CQ_DotProduct(T const a[CQ_DIMENSIONS], T const b[CQ_DIMENSIONS]) {
	T dot = (T) 0;
	for (std::size_t x = 0; x < CQ_DIMENSIONS; ++x) {
		dot += a[x] * b[x];
	}
	return dot;
}

struct cq_splitter_t final {
	int axis;
	int dist;
	double numpoints[2];
}; // partition the space into { point: point[axis] < dist }
   // and { point: point[axis] >= dist }

struct cq_node_t final {
	bool isleafnode;
	cq_node_t* parentnode;
	cq_node_t* childrennode[2];

	int numpoints; // numpoints > 0
	unsigned char (*refpoints)[CQ_DIMENSIONS];
	double centerofpoints[CQ_DIMENSIONS];

	bool needsplit;
	cq_splitter_t bestsplitter;
	double splitpriority;
}; // a cuboid region; the root node is the entire cube whose size
   // is 255

struct cq_searchnode_t final {
	bool isleafnode;
	cq_searchnode_t* childrennode[2];

	int planeaxis;
	int planedist;

	int result;
};

static void CQ_SelectPartition(cq_node_t* node) {
	CQ_VectorClear(node->centerofpoints);
	for (int i = 0; i < node->numpoints; i++) {
		CQ_VectorAdd(
			node->centerofpoints, node->refpoints[i], node->centerofpoints
		);
	}
	CQ_VectorScale(
		node->centerofpoints,
		1 / (double) node->numpoints,
		node->centerofpoints
	);

	node->needsplit = false;
	for (int k = 0; k < CQ_DIMENSIONS; k++) {
		double count;
		std::array<double, 256> counts;
		std::array<double, CQ_DIMENSIONS> sum;
		std::array<std::array<double, CQ_DIMENSIONS>, 256> sums;

		double bucketsums[256][CQ_DIMENSIONS];
		std::array<int, 256> bucketsizes{};

		unsigned char const(*nodepoints)[CQ_DIMENSIONS] = node->refpoints;
		int const nodenumpoints = node->numpoints;

		memset(bucketsums, 0, 256 * sizeof(double[CQ_DIMENSIONS]));
		for (int i = 0; i < nodenumpoints; i++) {
			int j = nodepoints[i][k];
			bucketsizes[j]++;
			CQ_VectorAdd(bucketsums[j], nodepoints[i], bucketsums[j]);
		}

		int min = 256;
		int max = -1;
		count = 0;
		sum = {};
		for (int j = 0; j < 256; j++) {
			counts[j] = count;
			sums[j] = sum;
			count += bucketsizes[j];
			for (std::size_t x = 0; x < CQ_DIMENSIONS; ++x) {
				sum[x] = sum[x] + bucketsums[j][x];
			}
			if (bucketsizes[j] > 0) {
				if (j < min) {
					min = j;
				}
				if (j > max) {
					max = j;
				}
			}
		}
		if (max < min) {
			Error("CQ_SelectPartition: internal error");
		}
		// sweep along the axis and find the plane that maximize square
		// error reduction
		for (int j = min + 1; j < max + 1; j++) {
			double priority = 0; // the decrease in total square deviation
			priority -= dot_product(sum, sum) / count;
			priority += dot_product(sums[j], sums[j]) / counts[j];
			double3_array remain;
			remain = vector_subtract(
				sum, sums[j]
			); // sums and counts are precise (have no round-off error)
			priority += dot_product(remain, remain) / (count - counts[j]);
			if (node->needsplit == false
			    || priority > node->splitpriority + 0.1
			    || priority >= node->splitpriority - 0.1
			        && fabs(counts[j] - count / 2) < fabs(
						   node->bestsplitter.numpoints[0] - count / 2
					   )) {
				node->needsplit = true;
				node->splitpriority = priority;
				node->bestsplitter.axis = k;
				node->bestsplitter.dist = j;
				node->bestsplitter.numpoints[0] = counts[j];
				node->bestsplitter.numpoints[1] = count - counts[j];
			}
		}
	}
}

static cq_searchnode_t* CQ_AllocSearchTree(int maxcolors) {
	cq_searchnode_t* searchtree;
	searchtree = (cq_searchnode_t*) malloc(
		(2 * maxcolors - 1) * sizeof(cq_searchnode_t)
	);
	hlassume(searchtree != nullptr, assume_msg::NoMemory);
	return searchtree;
}

static void CQ_FreeSearchTree(cq_searchnode_t* searchtree) {
	free(searchtree);
}

static void CQ_CreatePalette(
	int numpoints,
	std::array<std::uint8_t, CQ_DIMENSIONS> const * points,
	int maxcolors,
	std::array<std::uint8_t, CQ_DIMENSIONS>* colors_out,
	int& numcolors_out,
	cq_searchnode_t* searchtree_out
) //[2 * maxcolors - 1]
{
	if (numpoints <= 0 || maxcolors <= 0) {
		numcolors_out = 0;
		return;
	}

	unsigned char(*pointarray)[CQ_DIMENSIONS];
	pointarray = (unsigned char(*)[CQ_DIMENSIONS]
	) malloc(numpoints * sizeof(unsigned char[CQ_DIMENSIONS]));
	hlassume(pointarray != nullptr, assume_msg::NoMemory);
	memcpy(
		pointarray,
		points,
		numpoints * sizeof(std::array<std::uint8_t, CQ_DIMENSIONS>)
	);

	cq_node_t* n;
	cq_searchnode_t* s;
	int numnodes = 0;
	int maxnodes = 2 * maxcolors - 1;
	cq_node_t* nodes = (cq_node_t*) malloc(maxnodes * sizeof(cq_node_t));
	hlassume(nodes != nullptr, assume_msg::NoMemory);

	n = &nodes[0];
	numnodes++;

	n->isleafnode = true;
	n->parentnode = nullptr;
	n->numpoints = numpoints;
	n->refpoints = pointarray;
	CQ_SelectPartition(n);

	for (int i = 1; i < maxcolors; i++) {
		bool needsplit;
		double bestpriority;
		cq_node_t* bestnode;

		needsplit = false;
		for (int j = 0; j < numnodes; j++) {
			n = &nodes[j];
			if (!n->isleafnode || !n->needsplit) {
				continue;
			}
			if (needsplit == false
			    || n->splitpriority > bestpriority + 0.1) {
				needsplit = true;
				bestpriority = n->splitpriority;
				bestnode = n;
			}
		}
		if (!needsplit) {
			break;
		}

		bestnode->isleafnode = false;
		for (int k = 0; k < 2; k++) {
			n = &nodes[numnodes];
			numnodes++;
			if (numnodes > maxnodes) {
				Error("CQ_CreatePalette: internal error");
			}

			bestnode->childrennode[k] = n;
			n->isleafnode = true;
			n->parentnode = bestnode;
			n->numpoints = 0;
			n->refpoints = nullptr;
		}

		// partition the points using the best splitter
		{
			int const splitaxis = bestnode->bestsplitter.axis;
			int const splitdist = bestnode->bestsplitter.dist;
			int const numpoints = bestnode->numpoints;
			unsigned char(*points)[CQ_DIMENSIONS] = bestnode->refpoints;

			unsigned char(*left)[CQ_DIMENSIONS];
			unsigned char(*right)[CQ_DIMENSIONS];
			left = &bestnode->refpoints[0];
			right = &bestnode->refpoints[bestnode->numpoints - 1];
			while (1) {
				while ((*left)[splitaxis] < splitdist) {
					left++;
				}
				while ((*right)[splitaxis] >= splitdist) {
					right--;
				}
				if (left >= right) {
					break;
				}
				unsigned char tmp[CQ_DIMENSIONS];
				CQ_VectorCopy(*left, tmp);
				CQ_VectorCopy(*right, *left);
				CQ_VectorCopy(tmp, *right);
			}
			if (right != left - 1) {
				Error("CQ_CreatePalette: internal error");
			}

			bestnode->childrennode[0]->numpoints = left
				- bestnode->refpoints;
			bestnode->childrennode[0]->refpoints = bestnode->refpoints;
			bestnode->childrennode[1]->numpoints
				= &bestnode->refpoints[bestnode->numpoints] - left;
			bestnode->childrennode[1]->refpoints = left;
			if (bestnode->childrennode[0]->numpoints <= 0
			    || bestnode->childrennode[0]->numpoints
			        != bestnode->bestsplitter.numpoints[0]) {
				Error("CQ_CreatePalette: internal error");
			}
			if (bestnode->childrennode[1]->numpoints <= 0
			    || bestnode->childrennode[1]->numpoints
			        != bestnode->bestsplitter.numpoints[1]) {
				Error("CQ_CreatePalette: internal error");
			}
		}

		CQ_SelectPartition(bestnode->childrennode[0]);
		CQ_SelectPartition(bestnode->childrennode[1]);
	}

	for (int i = 0; i < numnodes; i++) {
		n = &nodes[i];
		s = &searchtree_out[i];
		s->isleafnode = n->isleafnode;
		if (!n->isleafnode) {
			s->planeaxis = n->bestsplitter.axis;
			s->planedist = n->bestsplitter.dist;
			s->childrennode[0]
				= &searchtree_out[n->childrennode[0] - nodes];
			s->childrennode[1]
				= &searchtree_out[n->childrennode[1] - nodes];
		}
	}

	numcolors_out = 0;
	n = &nodes[0];
	while (1) {
		while (!n->isleafnode) {
			n = n->childrennode[0];
		}
		s = &searchtree_out[n - nodes];
		s->result = numcolors_out;
		for (int k = 0; k < CQ_DIMENSIONS; k++) {
			int val = (int) floor(n->centerofpoints[k] + 0.5 + 0.00001);
			val = std::max(0, std::min(val, 255));
			colors_out[numcolors_out][k] = val;
		}
		numcolors_out++;
		while (n->parentnode) {
			if (n == n->parentnode->childrennode[0]) {
				break;
			}
			n = n->parentnode;
		}
		if (!n->parentnode) {
			break;
		}
		n = n->parentnode->childrennode[1];
	}

	if (2 * numcolors_out - 1 != numnodes) {
		Error("CQ_CreatePalette: internal error");
	}

	free(pointarray);
	free(nodes);
}

static void CQ_MapPoint_r(
	int* bestdist,
	int* best,
	cq_searchnode_t* node,
	std::array<std::uint8_t, CQ_DIMENSIONS> const * colors,
	std::array<std::uint8_t, CQ_DIMENSIONS> const & point,
	int searchradius
) {
	while (!node->isleafnode) {
		int dist = point[node->planeaxis] - node->planedist;
		if (dist <= -searchradius) {
			node = node->childrennode[0];
		} else if (dist >= searchradius - 1) {
			node = node->childrennode[1];
		} else {
			CQ_MapPoint_r(
				bestdist,
				best,
				node->childrennode[0],
				colors,
				point,
				searchradius
			);
			CQ_MapPoint_r(
				bestdist,
				best,
				node->childrennode[1],
				colors,
				point,
				searchradius
			);
			return;
		}
	}
	int dist = 0;
	for (int k = 0; k < CQ_DIMENSIONS; k++) {
		dist += (colors[node->result][k] - point[k])
			* (colors[node->result][k] - point[k]);
	}
	if (dist <= *bestdist) {
		if (dist < *bestdist || node->result < *best) {
			*bestdist = dist;
			*best = node->result;
		}
	}
}

static int CQ_MapPoint(
	std::array<std::uint8_t, CQ_DIMENSIONS> const & point,
	std::array<std::uint8_t, CQ_DIMENSIONS> const * colors,
	int numcolors,
	cq_searchnode_t* searchtree
) {
	if (numcolors <= 0) {
		Error("CQ_MapPoint: internal error");
	}

	cq_searchnode_t* node;
	int bestdist;
	int best;
	int searchradius;

	for (node = searchtree; !node->isleafnode;) {
		node
			= node->childrennode[point[node->planeaxis] >= node->planedist];
	}
	best = node->result;
	bestdist = 0;
	for (std::size_t k = 0; k < CQ_DIMENSIONS; ++k) {
		bestdist += (colors[best][k] - point[k])
			* (colors[best][k] - point[k]);
	}

	searchradius = (int) std::ceil(std::sqrt((double) bestdist) + 0.1);
	CQ_MapPoint_r(
		&bestdist, &best, searchtree, colors, point, searchradius
	);
	return best;
}

// =====================================================================================
//  EmbedLightmapInTextures
//      check for "zhlt_embedlightmap" and update g_dfaces, g_texinfo,
//      g_dtexdata and g_dlightdata
// =====================================================================================

#define RADTEXTURES_MAX \
	2048 // should be smaller than 62 * 62 and smaller than MAX_MAP_TEXTURES
static int g_newtextures_num = 0;
static byte* g_newtextures_data[RADTEXTURES_MAX];
static int g_newtextures_size[RADTEXTURES_MAX];

int NewTextures_GetCurrentMiptexIndex() {
	dmiptexlump_t* texdata = (dmiptexlump_t*) g_dtexdata.data();
	return texdata->nummiptex + g_newtextures_num;
}

void NewTextures_PushTexture(int size, void* data) {
	if (g_newtextures_num >= RADTEXTURES_MAX) {
		Error(
			"the number of textures created by hlrad has exceeded its internal limit(%d).",
			(int) RADTEXTURES_MAX
		);
	}
	g_newtextures_data[g_newtextures_num] = (byte*) malloc(size);
	hlassume(
		g_newtextures_data[g_newtextures_num] != nullptr,
		assume_msg::NoMemory
	);
	memcpy(g_newtextures_data[g_newtextures_num], data, size);
	g_newtextures_size[g_newtextures_num] = size;
	g_newtextures_num++;
}

void NewTextures_Write() {
	if (!g_newtextures_num) {
		return;
	}

	int i;
	dmiptexlump_t* texdata = (dmiptexlump_t*) g_dtexdata.data();

	std::byte* dataaddr
		= (std::byte*) &texdata->dataofs[texdata->nummiptex];
	int datasize = (g_dtexdata.data() + g_texdatasize) - dataaddr;
	std::byte* newdataaddr
		= (std::byte*) &texdata
			  ->dataofs[texdata->nummiptex + g_newtextures_num];
	hlassume(
		g_texdatasize + (newdataaddr - dataaddr) <= g_max_map_miptex,
		assume_msg::exceeded_MAX_MAP_MIPTEX
	);
	memmove(newdataaddr, dataaddr, datasize);
	g_texdatasize += newdataaddr - dataaddr;
	for (i = 0; i < texdata->nummiptex; i++) {
		if (texdata->dataofs[i] < 0) // bad texture
		{
			continue;
		}
		texdata->dataofs[i] += newdataaddr - dataaddr;
	}

	hlassume(
		texdata->nummiptex + g_newtextures_num < MAX_MAP_TEXTURES,
		assume_msg::exceeded_MAX_MAP_TEXTURES
	);
	for (i = 0; i < g_newtextures_num; i++) {
		hlassume(
			g_texdatasize + g_newtextures_size[i] <= g_max_map_miptex,
			assume_msg::exceeded_MAX_MAP_MIPTEX
		);
		memcpy(
			g_dtexdata.data() + g_texdatasize,
			g_newtextures_data[i],
			g_newtextures_size[i]
		);
		texdata->dataofs[texdata->nummiptex + i] = g_texdatasize;
		g_texdatasize += g_newtextures_size[i];
	}
	texdata->nummiptex += g_newtextures_num;

	for (int i = 0; i < g_newtextures_num; i++) {
		free(g_newtextures_data[i]);
	}
	g_newtextures_num = 0;
}

static unsigned int Hash(int size, void* data) {
	unsigned int hash = 0;
	for (int i = 0; i < size; i++) {
		hash = 31 * hash + ((unsigned char*) data)[i];
	}
	return hash;
}

static void GetLightInt(
	dface_t* face,
	std::array<int, 2> texsize,
	int ix,
	int iy,
	float3_array& light
) {
	ix = std::max(0, std::min(ix, texsize[0]));
	iy = std::max(0, std::min(iy, texsize[1]));
	light = {};
	if (face->lightofs < 0) {
		return;
	}
	for (int k = 0; k < MAXLIGHTMAPS && face->styles[k] != 255; k++) {
		int8_rgb const * samples
			= &g_dlightdata
				  [face->lightofs / int8_rgb{}.size()
		           + k * (texsize[0] + 1) * (texsize[1] + 1)];
		if (face->styles[k] == 0) {
			int8_rgb const & s = samples[(iy * (texsize[0] + 1) + ix)];
			light = vector_add(
				light, float3_array{ float(s[0]), float(s[1]), float(s[2]) }
			);
		}
	}
}

static void GetLight(
	dface_t* face,
	std::array<int, 2> texsize,
	double x,
	double y,
	float3_array& light
) {
	int ix = (int) floor(x);
	int iy = (int) floor(y);
	float dx = x - ix;
	dx = std::max(0.0f, std::min(dx, 1.0f));
	float dy = y - iy;
	dy = std::max(0.0f, std::min(dy, 1.0f));

	// do bilinear interpolation
	float3_array light00, light10, light01, light11;
	GetLightInt(face, texsize, ix, iy, light00);
	GetLightInt(face, texsize, ix + 1, iy, light10);
	GetLightInt(face, texsize, ix, iy + 1, light01);
	GetLightInt(face, texsize, ix + 1, iy + 1, light11);
	float3_array light0 = vector_scale(light00, 1 - dy);
	light0 = vector_fma(light01, dy, light0);
	float3_array light1 = vector_scale(light10, 1 - dy);
	light1 = vector_fma(light11, dy, light1);
	light = vector_scale(light0, 1 - dx);
	light = vector_fma(light1, dx, light);
}

static std::optional<wad_texture_name>
GetValidTextureName(std::uint32_t miptex) {
	int const numtextures = g_texdatasize
		? ((dmiptexlump_t*) g_dtexdata.data())->nummiptex
		: 0;

	if (miptex >= numtextures) {
		return std::nullopt;
	}
	std::int32_t offset
		= ((dmiptexlump_t*) g_dtexdata.data())->dataofs[miptex];
	int size = g_texdatasize - offset;
	if (offset < 0
	    || g_dtexdata.data() + offset
	        < (std::byte*) &((dmiptexlump_t*) g_dtexdata.data())
	              ->dataofs[numtextures]
	    || size < (int) sizeof(miptex_t)) {
		return std::nullopt;
	}

	wad_texture_name const textureName
		= ((miptex_t const &) g_dtexdata.data()[offset]).name;

	if (textureName.is_any_embedded_lightmap()) {
		return std::nullopt;
	}

	return textureName;
}

void EmbedLightmapInTextures() {
	if (g_dlightdata.empty()) {
		// HLRAD hasn't run
		return;
	}
	if (!g_texdatasize) {
		// texdata hasn't been initialized
		return;
	}
	if (g_notextures) {
		// HLRAD didn't load the WAD files
		return;
	}

	int i, j, k;
	int miplevel;
	int count = 0;
	int count_bytes = 0;
	bool logged = false;

	for (i = 0; i < g_numfaces; i++) {
		dface_t* f = &g_dfaces[i];

		if (f->lightofs == -1) // Some faces don't have a lightmap
		{
			continue;
		}
		if (f->texinfo >= g_numtexinfo) {
			continue;
		}

		entity_t* ent = g_face_entity[i];
		int originaltexinfonum = f->texinfo;
		texinfo_t* originaltexinfo = &g_texinfo[originaltexinfonum];

		auto maybeTexname = GetValidTextureName(originaltexinfo->miptex);

		if (!maybeTexname) {
			continue;
		}
		wad_texture_name const texname = maybeTexname.value();

		radtexture_t* tex = &g_textures[originaltexinfo->miptex];

		if (ent == &g_entities[0]) // World
		{
			continue;
		}
		if (texname.is_ordinary_sky()
		    || originaltexinfo->has_special_flag()) // Skip special surfaces
		{
			continue;
		}
		if (!IntForKey(ent, u8"zhlt_embedlightmap")) {
			continue;
		}

		if (!logged) {
			Log("\n");
			Log("Embed Lightmap : ");
			Developer(developer_level::message, "\n");
			logged = true;
		}

		bool poweroftwo = DEFAULT_EMBEDLIGHTMAP_POWEROFTWO;
		float denominator = DEFAULT_EMBEDLIGHTMAP_DENOMINATOR;
		float gamma = DEFAULT_EMBEDLIGHTMAP_GAMMA;
		int resolution = DEFAULT_EMBEDLIGHTMAP_RESOLUTION;
		if (IntForKey(ent, u8"zhlt_embedlightmapresolution")) {
			resolution = IntForKey(ent, u8"zhlt_embedlightmapresolution");
			if (resolution <= 0 || resolution > TEXTURE_STEP
			    || ((resolution - 1) & resolution) != 0) {
				Error(
					"resolution cannot be %d; valid values are 1, 2, 4 ... %d.",
					resolution,
					(int) TEXTURE_STEP
				);
			}
		}

		// calculate texture size and allocate memory for all miplevels

		int texturesize[2];
		byte(*texturemips[MIPLEVELS]
		)[4]; // red, green, blue and alpha channel
		int s, t;
		std::array<int, 2>
			texsize; // texturesize = (texsize + 1) * TEXTURE_STEP
		std::array<int, 2> side;

		face_extents const texMinsMaxs{ get_face_extents(i) };
		texsize[0] = texMinsMaxs.maxs[0] - texMinsMaxs.mins[0];
		texsize[1] = texMinsMaxs.maxs[1] - texMinsMaxs.mins[1];
		if (texsize[0] < 0 || texsize[1] < 0
		    || texsize[0] > MAX_SURFACE_EXTENT
		    || texsize[1] > MAX_SURFACE_EXTENT) {
			Warning(
				"skipped a face with bad surface extents @ (%4.3f %4.3f %4.3f)",
				g_face_centroids[i][0],
				g_face_centroids[i][1],
				g_face_centroids[i][2]
			);
			continue;
		}

		for (k = 0; k < 2; k++) {
			texturesize[k] = (texsize[k] + 1) * TEXTURE_STEP;
			if (texturesize[k]
			    < texsize[k] * TEXTURE_STEP + resolution * 4) {
				texturesize[k] = texsize[k] * TEXTURE_STEP
					+ resolution * 4; // prevent edge bleeding
			}
			texturesize[k] = (texturesize[k] + resolution - 1) / resolution;
			texturesize[k] += 15
				- (texturesize[k] + 15) % 16; // must be multiples of 16
			if (poweroftwo) {
				for (j = 0; j <= 30; j++) {
					if ((1 << j) >= texturesize[k]) {
						texturesize[k] = (1 << j);
						break;
					}
				}
			}
			side[k] = (texturesize[k] * resolution
			           - texsize[k] * TEXTURE_STEP)
				/ 2;
		}

		// red, green, blue and alpha channel; the last
		// one is number of samples
		std::array<float, 5>* texture = (std::array<float, 5>*) malloc(
			texturesize[0] * texturesize[1] * sizeof(std::array<float, 5>)
		);
		hlassume(texture != nullptr, assume_msg::NoMemory);
		for (miplevel = 0; miplevel < MIPLEVELS; miplevel++) {
			texturemips[miplevel] = (byte(*)[4]) malloc(
				(texturesize[0] >> miplevel) * (texturesize[1] >> miplevel)
				* sizeof(byte[4])
			);
			hlassume(
				texturemips[miplevel] != nullptr, assume_msg::NoMemory
			);
		}

		// calculate the texture

		for (t = 0; t < texturesize[1]; t++) {
			for (s = 0; s < texturesize[0]; s++) {
				texture[t * texturesize[0] + s] = {};
			}
		}
		for (t = -side[1]; t < texsize[1] * TEXTURE_STEP + side[1]; t++) {
			for (s = -side[0]; s < texsize[0] * TEXTURE_STEP + side[0];
			     s++) {
				double s_vec, t_vec;
				double src_s, src_t;
				std::int32_t src_is, src_it;
				std::uint8_t src_index;
				std::array<std::uint8_t, 3> src_color;
				double dest_s, dest_t;
				std::int32_t dest_is, dest_it;
				std::array<float, 5>* dest;
				double light_s, light_t;
				float3_array light;

				s_vec = s + texMinsMaxs.mins[0] * TEXTURE_STEP + 0.5;
				t_vec = t + texMinsMaxs.mins[1] * TEXTURE_STEP + 0.5;

				if (resolution == 1) {
					dest_s = s_vec;
					dest_t = t_vec;
				} else // the final blurred texture is shifted by a half
				       // pixel so that lightmap samples align with the
				       // center of pixels
				{
					dest_s = s_vec / resolution + 0.5;
					dest_t = t_vec / resolution + 0.5;
				}
				dest_s = dest_s
					- texturesize[0] * floor(dest_s / texturesize[0]);
				dest_t = dest_t
					- texturesize[1] * floor(dest_t / texturesize[1]);
				dest_is = (std::int32_t) floor(dest_s
				); // dest_is = dest_s % texturesize[0]
				dest_it = (std::int32_t) floor(dest_t
				); // dest_it = dest_t % texturesize[1]
				dest_is = std::max(
					0, std::min(dest_is, texturesize[0] - 1)
				);
				dest_it = std::max(
					0, std::min(dest_it, texturesize[1] - 1)
				);
				dest = &texture[dest_it * texturesize[0] + dest_is];

				src_s = s_vec;
				src_t = t_vec;
				src_s = src_s - tex->width * floor(src_s / tex->width);
				src_t = src_t - tex->height * floor(src_t / tex->height);
				src_is = (std::int32_t) floor(src_s
				); // src_is = src_s % tex->width
				src_it = (std::int32_t) floor(src_t
				); // src_it = src_t % tex->height
				src_is = std::max(0, std::min(src_is, tex->width - 1));
				src_it = std::max(0, std::min(src_it, tex->height - 1));
				src_index = tex->canvas[src_it * tex->width + src_is];
				src_color = tex->palette[src_index];

				// get light from the center of the destination pixel
				light_s = (s_vec + resolution * (dest_is + 0.5 - dest_s))
						/ TEXTURE_STEP
					- texMinsMaxs.mins[0];
				light_t = (t_vec + resolution * (dest_it + 0.5 - dest_t))
						/ TEXTURE_STEP
					- texMinsMaxs.mins[1];
				GetLight(f, texsize, light_s, light_t, light);

				(*dest)[4] += 1;
				if (!(texname.is_transparent_or_decal() && src_index == 255
				    )) {
					for (k = 0; k < 3; k++) {
						float v = src_color[k]
							* pow(light[k] / denominator, gamma);
						(*dest)[k] += 255
							* std::max(0.0f, std::min(v, 255.0f));
					}
					(*dest)[3] += 255;
				}
			}
		}
		for (t = 0; t < texturesize[1]; t++) {
			for (s = 0; s < texturesize[0]; s++) {
				std::array<float, 5>* src
					= &texture[t * texturesize[0] + s];
				byte(*dest)[4] = &texturemips[0][t * texturesize[0] + s];

				if ((*src)[4] == 0) // no samples (outside face range?)
				{
					(*dest)[0] = 0;
					(*dest)[1] = 0;
					(*dest)[2] = 0;
					(*dest)[3] = 255;
				} else if ((*src)[3] / (*src)[4]
				           <= 0.4 * 255) // transparent
				{
					(*dest)[0] = 0;
					(*dest)[1] = 0;
					(*dest)[2] = 0;
					(*dest)[3] = 0;
				} else // normal
				{
					for (j = 0; j < 3; j++) {
						int val = (int) floor((*src)[j] / (*src)[3] + 0.5);
						(*dest)[j] = std::max(0, std::min(val, 255));
					}
					(*dest)[3] = 255;
				}
			}
		}

		for (miplevel = 1; miplevel < MIPLEVELS; miplevel++) {
			for (t = 0; t < (texturesize[1] >> miplevel); t++) {
				for (s = 0; s < (texturesize[0] >> miplevel); s++) {
					byte(*src[4])[4];
					byte(*dest)[4];

					dest = &texturemips[miplevel]
									   [t * (texturesize[0] >> miplevel)
					                    + s];
					src[0] = &texturemips[miplevel - 1]
										 [(2 * t)
					                          * (texturesize[0]
					                             >> (miplevel - 1))
					                      + (2 * s)];
					src[1] = &texturemips[miplevel - 1]
										 [(2 * t)
					                          * (texturesize[0]
					                             >> (miplevel - 1))
					                      + (2 * s + 1)];
					src[2] = &texturemips[miplevel - 1]
										 [(2 * t + 1)
					                          * (texturesize[0]
					                             >> (miplevel - 1))
					                      + (2 * s)];
					src[3] = &texturemips[miplevel - 1]
										 [(2 * t + 1)
					                          * (texturesize[0]
					                             >> (miplevel - 1))
					                      + (2 * s + 1)];

					std::array<double, 4> average{};
					for (k = 0; k < 4; k++) {
						for (j = 0; j < 3; j++) {
							average[j] += (*src[k])[3] * (*src[k])[j];
						}
						average[3] += (*src[k])[3];
					}

					if (average[3] / 4 <= 0.4 * 255) {
						std::fill_n(*dest, 4, 0);
					} else {
						for (j = 0; j < 3; j++) {
							int val = (int
							) floor(average[j] / average[3] + 0.5);
							(*dest)[j] = std::max(0, std::min(val, 255));
						}
						(*dest)[3] = 255;
					}
				}
			}
		}

		// create its palette

		std::array<std::array<std::uint8_t, 3>, 256> palette;
		cq_searchnode_t* palettetree = CQ_AllocSearchTree(256);
		int paletteoffset;
		int palettenumcolors;

		{
			int palettemaxcolors;
			int numsamplepoints;
			std::array<std::uint8_t, 3>* samplepoints;

			if (texname.is_transparent_or_decal()) {
				paletteoffset = 0;
				palettemaxcolors = 255;
				palette[255] = tex->palette[255]; // The transparency color
			}
			/*else if (texname[0] == '!')
			{
			    paletteoffset = 16; // because the 4th entry and the 5th
			entry are reserved for fog color and fog density for (j = 0; j <
			16; j++)
			    {
			        palette[j] = tex->palette[j];
			    }
			    palettemaxcolors = 256 - 16;
			}*/
			else {
				paletteoffset = 0;
				palettemaxcolors = 256;
			}

			samplepoints = (std::array<std::uint8_t, 3>*) malloc(
				texturesize[0] * texturesize[1]
				* sizeof(std::array<std::uint8_t, 3>)
			);
			hlassume(samplepoints != nullptr, assume_msg::NoMemory);
			numsamplepoints = 0;
			for (t = 0; t < texturesize[1]; t++) {
				for (s = 0; s < texturesize[0]; s++) {
					byte(*src)[4] = &texturemips[0][t * texturesize[0] + s];
					if ((*src)[3] > 0) {
						std::copy_n(
							*src, 3, samplepoints[numsamplepoints].begin()
						);
						numsamplepoints++;
					}
				}
			}

			CQ_CreatePalette(
				numsamplepoints,
				samplepoints,
				palettemaxcolors,
				&palette[paletteoffset],
				palettenumcolors,
				palettetree
			);
			for (j = palettenumcolors; j < palettemaxcolors; j++) {
				palette[paletteoffset + j] = {};
			}

			free(samplepoints);
		}

		// emit a texinfo

		hlassume(
			g_numtexinfo < INITIAL_MAX_MAP_TEXINFO,
			assume_msg::exceeded_INITIAL_MAX_MAP_TEXINFO
		);
		f->texinfo = g_numtexinfo;
		texinfo_t* info = &g_texinfo[g_numtexinfo];
		g_numtexinfo++;

		*info = g_texinfo[originaltexinfonum];
		if (resolution != 1) {
			// apply a scale and a shift over the original vectors
			for (k = 0; k < 2; k++) {
				info->vecs[k].xyz = vector_scale(
					info->vecs[k].xyz, 1.0f / resolution
				);
				info->vecs[k].offset = info->vecs[k].offset / resolution
					+ 0.5;
			}
		}
		info->miptex = NewTextures_GetCurrentMiptexIndex();

		// emit a texture

		std::size_t miptexsize = sizeof(miptex_t);
		for (miplevel = 0; miplevel < MIPLEVELS; miplevel++) {
			miptexsize += (texturesize[0] >> miplevel)
				* (texturesize[1] >> miplevel);
		}
		miptexsize += 2 + 256 * 3 + 2;
		auto miptex{ std::make_unique_for_overwrite<miptex_t[]>(miptexsize
		) };
		miptex[0] = {};

		miptex[0].width = texturesize[0];
		miptex[0].height = texturesize[1];
		byte* p = (byte*) &miptex[1];
		for (miplevel = 0; miplevel < MIPLEVELS; miplevel++) {
			miptex[0].offsets[miplevel] = p - (byte*) &miptex[0];
			for (int t = 0; t < (texturesize[1] >> miplevel); t++) {
				for (int s = 0; s < (texturesize[0] >> miplevel); s++) {
					byte(*src
					)[4] = &texturemips[miplevel]
									   [t * (texturesize[0] >> miplevel)
					                    + s];
					if ((*src)[3] > 0) {
						if (palettenumcolors) {
							std::array<std::uint8_t, 3> point;

							std::copy_n(*src, 3, point.begin());
							*p = paletteoffset
								+ CQ_MapPoint(
									 point,
									 &palette[paletteoffset],
									 palettenumcolors,
									 palettetree
								);
						} else // this should never happen
						{
							*p = paletteoffset + 0;
						}
					} else {
						*p = 255;
					}
					p++;
				}
			}
		}
		*(short*) p = 256;
		p += 2;
		std::memcpy(p, palette.data(), 256 * 3);
		p += 256 * 3;
		*(short*) p = 0;
		p += 2;
		if (p != (byte*) &miptex[0] + miptexsize) {
			Error("EmbedLightmapInTextures: internal error");
		}

		std::array<char8_t, wad_texture_name_max_length_with_last_null>
			embeddedLightmapName{};
		using namespace std::literals;
		if (texname.is_transparent_or_decal()) {
			std::ranges::copy(u8"{_rad"sv, embeddedLightmapName.data());
		} else if (texname.is_water()) {
			std::ranges::copy(u8"!_rad"sv, embeddedLightmapName.data());
		} else {
			std::ranges::copy(u8"__rad"sv, embeddedLightmapName.data());
		}
		if (originaltexinfonum < 0 || originaltexinfonum > 99999) {
			Error(
				"EmbedLightmapInTextures: internal error: texinfo out of range"
			);
		}
		static_assert(
			embedded_lightmap_texture_name_original_texinfo_index_starts_at
			== 5
		);
		embeddedLightmapName[5] = '0'
			+ (originaltexinfonum / 10000)
				% 10; // store the original texinfo
		embeddedLightmapName[6] = '0' + (originaltexinfonum / 1000) % 10;
		embeddedLightmapName[7] = '0' + (originaltexinfonum / 100) % 10;
		embeddedLightmapName[8] = '0' + (originaltexinfonum / 10) % 10;
		embeddedLightmapName[9] = '0' + (originaltexinfonum) % 10;
		static_assert(
			embedded_lightmap_texture_name_original_texinfo_index_length
			== 5
		);
		char table[36];
		for (int k = 0; k < 36; k++) {
			table[k] = k >= 10 ? 'a' + (k - 10)
							   : '0' + k; // same order as the ASCII table
		}
		unsigned int hash = Hash(miptexsize, &miptex[0]);
		embeddedLightmapName[10] = table[(hash / 36 / 36) % 26 + 10];
		embeddedLightmapName[11] = table[(hash / 36) % 36];
		embeddedLightmapName[12] = table[(hash) % 36];
		embeddedLightmapName[13] = table[(count / 36) % 36];
		embeddedLightmapName[14] = table[(count) % 36];
		embeddedLightmapName[15] = '\0';

		miptex[0].name = wad_texture_name{ embeddedLightmapName.begin() };

		NewTextures_PushTexture(miptexsize, &miptex[0]);
		count++;
		count_bytes += miptexsize;
		Developer(
			developer_level::message,
			"Created texture '%s' for face (texture %s) at (%4.3f %4.3f %4.3f)\n",
			miptex[0].name.c_str(),
			texname.c_str(),
			g_face_centroids[i][0],
			g_face_centroids[i][1],
			g_face_centroids[i][2]
		);

		CQ_FreeSearchTree(palettetree);

		free(texture);
		for (miplevel = 0; miplevel < MIPLEVELS; miplevel++) {
			free(texturemips[miplevel]);
		}
	}
	NewTextures_Write(); // update texdata now

	if (logged) {
		Log("added %d texinfos and textures (%d bytes)\n",
		    count,
		    count_bytes);
	}
}
