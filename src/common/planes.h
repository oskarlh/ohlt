#pragma once

#include "hashing.h"
#include "mathtypes.h"

#include <array>
#include <cmath>
#include <concepts>

// TODO: This can be larger, because although faces can only
// use plane 0-32767, clipnodes can use plane 0-65535.
constexpr std::ptrdiff_t MAX_MAP_PLANES = 32768;

// (from email): I have been building a rather complicated map, and
// using your latest tools (1.61) it seemed to compile fine.  However,
// in game, the engine was dropping a lot of faces from almost every
// FUNC_WALL, and also caused a strange texture phenomenon in software
// mode (see attached screen shot).  When I compiled with v1.41, I
// noticed that it hit the MAX_MAP_PLANES limit of 32k.  After deleting
// some brushes I was able to bring the map under the limit, and all of
// the previous errors went away.
constexpr std::ptrdiff_t MAX_INTERNAL_MAP_PLANES = 256 * 1024;

constexpr float PLANE_NORMAL_EPSILON = (1 / 8192.0f) / 2;

constexpr float PLANE_DIST_EPSILON = 0.04f;

enum class planetype : std::uint8_t {
	plane_x = 0,
	plane_y,
	plane_z,
	plane_anyx,
	plane_anyy,
	plane_anyz
};
constexpr planetype first_axial{ planetype::plane_x };
constexpr planetype last_axial{ planetype::plane_z };

template <any_vec3 Vec3>
constexpr Vec3 round_normal(Vec3 const & normal) {
	Vec3 roundedNormal;
	for (std::size_t i = 0; i < 3; ++i) {
		auto const rounded
			= std::round(float(normal[i]) * (1 / PLANE_NORMAL_EPSILON))
			* PLANE_NORMAL_EPSILON;
		auto const notNegativeZero = 0 + rounded;
		roundedNormal[i] = rounded;
	}
	return roundedNormal;
}

template <std::floating_point T>
constexpr planetype plane_type_for_normal(std::array<T, 3> const & normal
) noexcept {
	T const ax = std::abs(normal[0]);
	T const ay = std::abs(normal[1]);
	T const az = std::abs(normal[2]);
	if (ax > 1.0 - PLANE_NORMAL_EPSILON && ay < PLANE_NORMAL_EPSILON
		&& az < PLANE_NORMAL_EPSILON) {
		return planetype::plane_x;
	}

	if (ay > 1.0 - PLANE_NORMAL_EPSILON && az < PLANE_NORMAL_EPSILON
		&& ax < PLANE_NORMAL_EPSILON) {
		return planetype::plane_y;
	}

	if (az > 1.0 - PLANE_NORMAL_EPSILON && ax < PLANE_NORMAL_EPSILON
		&& ay < PLANE_NORMAL_EPSILON) {
		return planetype::plane_z;
	}

	if ((ax >= ay) && (ax >= az)) {
		return planetype::plane_anyx;
	}
	if ((ay >= ax) && (ay >= az)) {
		return planetype::plane_anyy;
	}
	return planetype::plane_anyz;
}

// The final plane type that ends up in the BSP
struct dplane_t final {
	std::array<float, 3> normal;
	float dist; // Distance from the origin
	planetype type;
	std::array<std::uint8_t, 3> zeroPaddingAfterType; // MUST be zeroes
};

// mapplane_t is generated by HLCSG and used by HLBSP. It is not the
// final plane type that ends up in the BSP - that's dplane_t
struct mapplane_t final {
	double3_array normal;
	double3_array origin;
	double dist; // Distance from the origin
	planetype type;
};

namespace std {
	template <>
	struct hash<mapplane_t> {
		constexpr std::size_t operator()(mapplane_t const & mapPlane
		) const noexcept {
			return hash_multiple(
				mapPlane.normal,
				mapPlane.origin,
				mapPlane.dist,
				mapPlane.type
			);
		}
	};
} // namespace std
